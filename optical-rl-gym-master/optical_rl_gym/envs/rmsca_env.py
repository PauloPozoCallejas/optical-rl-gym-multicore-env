# -*- coding: utf-8 -*-
"""RMSCA_env.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1inyGE3qkIQj9DXeT2UXUQUZu4AWQ0Fz8
"""

import gym
import copy
import math
import heapq
import logging
import functools
import numpy as np

from optical_rl_gym.utils import Service, Path
from .optical_network_env import OpticalNetworkEnv

class RMSCAEnv(OpticalNetworkEnv):

    metadata = {
        'metrics': ['service_blocking_rate', 'service_blocking_rate_since_reset',
                    'bit_rate_blocking_rate', 'bit_rate_blocking_rate_since_reset', 'external_fragmentation']
    }

    def __init__(self, topology=None,
                 episode_length=1000,
                 load=10,
                 mean_service_holding_time=10800.0,
                 num_spectrum_resources=100,
                 node_request_probabilities=None,
                 bit_rate_lower_bound=25,
                 bit_rate_higher_bound=100,
                 seed=None,
                 k_paths=5,
                 allow_rejection=False,
                 reset=True):
        super().__init__(topology,
                         episode_length=episode_length,
                         load=load,
                         mean_service_holding_time=mean_service_holding_time,
                         num_spectrum_resources=num_spectrum_resources,
                         node_request_probabilities=node_request_probabilities,
                         seed=seed, allow_rejection=allow_rejection,
                         k_paths=k_paths)
        assert 'modulations' in self.topology.graph

        # Number of cores

        self.cores = 3

        # specific attributes for elastic optical networks
        self.bit_rate_requested = 0
        self.bit_rate_provisioned = 0
        self.bit_rate_requested_since_reset = 0
        self.bit_rate_provisioned_since_reset = 0

        self.bit_rate_lower_bound = bit_rate_lower_bound
        self.bit_rate_higher_bound = bit_rate_higher_bound

        self.spectrum_slots_allocation = np.full((self.topology.number_of_edges() * self.cores, self.num_spectrum_resources),
                                                 fill_value=-1, dtype=np.int)

        # do we allow proactive rejection or not?
        self.reject_action = 1 if allow_rejection else 0

        # defining the observation and action spaces
        self.actions_output = np.zeros((self.k_paths + 1, 
                                        self.cores + 1,
                                       self.num_spectrum_resources + 1),
                                       dtype=int)
        self.actions_output_since_reset = np.zeros((self.k_paths + 1, 
                                                    self.cores + 1,
                                                   self.num_spectrum_resources + 1),
                                                   dtype=int)
        self.actions_taken = np.zeros((self.k_paths + 1, 
                                       self.cores + 1,
                                      self.num_spectrum_resources + 1),
                                      dtype=int)
        self.actions_taken_since_reset = np.zeros((self.k_paths + 1,
                                                   self.cores + 1,
                                                  self.num_spectrum_resources + 1),
                                                  dtype=int)
        self.action_space = gym.spaces.MultiDiscrete((self.k_paths + self.reject_action,
                                                      self.cores + self.reject_action,
                                                     self.num_spectrum_resources + self.reject_action))
        self.observation_space = gym.spaces.Dict(
            {'topology': gym.spaces.Discrete(10),
             'current_service': gym.spaces.Discrete(10)}
        )
        self.action_space.seed(self.rand_seed)
        self.observation_space.seed(self.rand_seed)

        self.logger = logging.getLogger('rmscaenv')
        if self.logger.isEnabledFor(logging.DEBUG):
            self.logger.warning(
                'Logging is enabled for DEBUG which generates a large number of messages. '
                'Set it to INFO if DEBUG is not necessary.')
        self._new_service = False
        if reset:
            self.reset(only_counters=False)

    def step(self, action: [int]):
        path, core, initial_slot = action[0], action[1], action[2]
        self.actions_output[path, core, initial_slot] += 1
        if path < self.k_paths and core < self.cores and initial_slot < self.num_spectrum_resources:  # action is for assigning a path
            slots = self.get_number_slots(self.k_shortest_paths[self.service.source, self.service.destination][path])
            XT_accomplish = self.Crosstalk_calculation(self.k_shortest_paths[self.service.source, self.service.destination][path], initial_slot, slots, core)
            self.logger.debug('{} processing action {} path {} and initial slot {} for {} slots'.format(self.service.service_id, action, path, initial_slot, slots))
            if self.is_path_free(self.k_shortest_paths[self.service.source, self.service.destination][path],
                                      initial_slot, slots, core) and XT_accomplish:
                    self._provision_path(self.k_shortest_paths[self.service.source, self.service.destination][path],
                                          initial_slot, slots, core)
                    self.service.accepted = True
                    self.actions_taken[path, core, initial_slot] += 1
                    self._add_release(self.service)
            else:
                self.service.accepted = False
        else:
            self.service.accepted = False

        if not self.service.accepted:
            self.actions_taken[self.k_paths, self.cores, self.num_spectrum_resources] += 1

        self.services_processed += 1
        self.services_processed_since_reset += 1
        self.bit_rate_requested += self.service.bit_rate
        self.bit_rate_requested_since_reset += self.service.bit_rate

        self.topology.graph['services'].append(self.service)

        reward = self.reward()
        info = {
                   'service_blocking_rate': (self.services_processed - self.services_accepted) / self.services_processed,
                   'service_blocking_rate_since_reset': (self.services_processed_since_reset - self.services_accepted_since_reset) / self.services_processed_since_reset,
                   'bit_rate_blocking_rate': (self.bit_rate_requested - self.bit_rate_provisioned) / self.bit_rate_requested,
                   'bit_rate_blocking_rate_since_reset': (self.bit_rate_requested_since_reset - self.bit_rate_provisioned_since_reset) / self.bit_rate_requested_since_reset
               }

        self._new_service = False
        self._next_service()
        return self.observation(), reward, self.services_processed_since_reset == self.episode_length, info

    def reset(self, only_counters=True):
        self.bit_rate_requested_since_reset = 0
        self.bit_rate_provisioned_since_reset = 0
        self.services_processed_since_reset = 0
        self.services_accepted_since_reset = 0
        self.actions_output_since_reset = np.zeros((self.k_paths + self.reject_action,
                                                    self.cores + self.reject_action,
                                                   self.num_spectrum_resources + self.reject_action),
                                                   dtype=int)
        self.actions_taken_since_reset = np.zeros((self.k_paths + self.reject_action,
                                                   self.cores + self.reject_action,
                                                  self.num_spectrum_resources + self.reject_action),
                                                  dtype=int)

        if only_counters:
            return self.observation()

        super().reset()

        self.bit_rate_requested = 0
        self.bit_rate_provisioned = 0

        self.topology.graph["available_slots"] = np.ones((self.topology.number_of_edges() * self.cores, self.num_spectrum_resources), dtype=int)

        self.spectrum_slots_allocation = np.full((self.topology.number_of_edges() * self.cores, self.num_spectrum_resources),
                                                 fill_value=-1, dtype=np.int)

        for idx, lnk in enumerate(self.topology.edges()):
                    self.topology[lnk[0]][lnk[1]]['external_fragmentation'] = 0.
        self.topology.graph["compactness"] = 0.
        self.topology.graph["throughput"] = 0.
        for idx, lnk in enumerate(self.topology.edges()):
            self.topology[lnk[0]][lnk[1]]['fragmentation'] = 0.
            self.topology[lnk[0]][lnk[1]]['compactness'] = 0.

        self._new_service = False
        self._next_service()
        return self.observation()

    def render(self, mode='human'):
        return

    def _provision_path(self, path: Path, initial_slot, number_slots, idc):
        # usage
        if not self.is_path_free(path, initial_slot, number_slots, idc):
            raise ValueError("Path {} has not enough capacity on slots {}-{}".format(path.node_list, path, initial_slot,
                                                                                     initial_slot + number_slots))

        self.logger.debug('{} assigning path {} on initial slot {} for {} slots'.format(self.service.service_id, path.node_list, initial_slot, number_slots))
        for i in range(len(path.node_list) - 1):
            self.topology.graph['available_slots'][((self.topology[path.node_list[i]][path.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * idc)),
                                                                            initial_slot:initial_slot + number_slots] = 0
            self.spectrum_slots_allocation[((self.topology[path.node_list[i]][path.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * idc)),
                                                        initial_slot:initial_slot + number_slots] = self.service.service_id
            self.topology[path.node_list[i]][path.node_list[i + 1]]['services'].append(self.service)
            self.topology[path.node_list[i]][path.node_list[i + 1]]['running_services'].append(self.service)
            self._update_link_stats(path.node_list[i], path.node_list[i + 1])
        self.topology.graph['running_services'].append(self.service)
        self.service.route = path
        self.service.core = idc
        self.service.initial_slot = initial_slot
        self.service.number_slots = number_slots
        self._update_network_stats()

        self.services_accepted += 1
        self.services_accepted_since_reset += 1
        self.bit_rate_provisioned += self.service.bit_rate
        self.bit_rate_provisioned_since_reset += self.service.bit_rate

    def _release_path(self, service: Service):
        for i in range(len(service.route.node_list) - 1):
            service.core = 0
            self.topology.graph['available_slots'][
                ((self.topology[service.route.node_list[i]][service.route.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * service.core)),
                                        service.initial_slot:service.initial_slot + service.number_slots] = 1
            self.spectrum_slots_allocation[((self.topology[service.route.node_list[i]][service.route.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * service.core)),
                                        service.initial_slot:service.initial_slot + service.number_slots] = -1
            self.topology[service.route.node_list[i]][service.route.node_list[i + 1]]['running_services'].remove(service)
            self._update_link_stats(service.route.node_list[i], service.route.node_list[i + 1])
        self.topology.graph['running_services'].remove(service)

    def _update_network_stats(self):
        last_update = self.topology.graph['last_update']
        time_diff = self.current_time - last_update
        if self.current_time > 0:
            last_throughput = self.topology.graph['throughput']
            last_compactness = self.topology.graph['compactness']

            cur_throughtput = 0.
            sum_slots_paths = 0 # this accounts for the sum of all Bi * Hi

            for service in self.topology.graph["running_services"]:
                cur_throughtput += service.bit_rate
                sum_slots_paths += service.number_slots * service.route.hops

            throughput = ((last_throughput * last_update) + (cur_throughtput * time_diff)) / self.current_time
            self.topology.graph['throughput'] = throughput

            # implementing fragmentation from https://ieeexplore.ieee.org/abstract/document/6476152

            # TODO: implement fragmentation
            sum_occupied = 0
            sum_unused_spectrum_blocks = 0
            for n1, n2 in self.topology.edges():
                # link = self.topology.graph['available_slots'][self.topology[n1][n2]['index'],:]
                # getting the blocks
                initial_indices, values, lengths = RMSCAEnv.rle(self.topology.graph['available_slots'][self.topology[n1][n2]['index'], :])
                used_blocks = [i for i, x in enumerate(values) if x == 0]
                if len(used_blocks) > 1:
                    lambda_min = initial_indices[used_blocks[0]]
                    lambda_max = initial_indices[used_blocks[-1]] + lengths[used_blocks[-1]]
                    sum_occupied += lambda_max - lambda_min # we do not put the "+1" because we use zero-indexed arrays

                    # evaluate again only the "used part" of the spectrum
                    internal_idx, internal_values, internal_lengths = RMSCAEnv.rle(
                        self.topology.graph['available_slots'][self.topology[n1][n2]['index'], lambda_min:lambda_max])
                    sum_unused_spectrum_blocks += np.sum(1 - internal_values)

            if sum_unused_spectrum_blocks > 0:
                cur_spectrum_compactness = (sum_occupied / sum_slots_paths) * (self.topology.number_of_edges() / sum_unused_spectrum_blocks)
                compactness = ((last_compactness * last_update) + (cur_spectrum_compactness * time_diff)) / self.current_time
                self.topology.graph['compactness'] = compactness

        self.topology.graph['last_update'] = self.current_time

    def _update_link_stats(self, node1: str, node2: str):
        last_update = self.topology[node1][node2]['last_update']
        time_diff = self.current_time - self.topology[node1][node2]['last_update']
        if self.current_time > 0:
            last_util = self.topology[node1][node2]['utilization']
            cur_util = (self.num_spectrum_resources - np.sum(
                self.topology.graph['available_slots'][self.topology[node1][node2]['index'], :])) / self.num_spectrum_resources
            utilization = ((last_util * last_update) + (cur_util * time_diff)) / self.current_time
            self.topology[node1][node2]['utilization'] = utilization

            slot_allocation = self.topology.graph['available_slots'][self.topology[node1][node2]['index'], :]

            # implementing fragmentation from https://ieeexplore.ieee.org/abstract/document/6421472
            last_external_fragmentation = self.topology[node1][node2]['external_fragmentation']

            cur_external_fragmentation = 0.
            cur_link_compactness = 0.
            if np.sum(slot_allocation) > 0:
                initial_indices, values, lengths = RMSCAEnv.rle(slot_allocation)

                # computing external fragmentation from https://ieeexplore.ieee.org/abstract/document/6421472
                unused_blocks = [i for i, x in enumerate(values) if x == 1]
                max_empty = 0
                if len(unused_blocks) > 1 and unused_blocks != [0, len(values) - 1]:
                    max_empty = max(lengths[unused_blocks])
                cur_external_fragmentation = 1. - (float(max_empty) / float(np.sum(slot_allocation)))

            # implementing fragmentation from https://ieeexplore.ieee.org/abstract/document/6421472
            last_fragmentation = self.topology[node1][node2]['fragmentation']
            last_compactness = self.topology[node1][node2]['compactness']

            cur_fragmentation = 0.
            cur_compactness = 0.
            if np.sum(slot_allocation) > 0:
                blocks = np.split(slot_allocation, np.where(np.diff(slot_allocation) != 0)[0] + 1)
                max_empty = 0
                for block in blocks:
                    if np.all(block == 1):
                        max_empty = max(max_empty, len(block))
                cur_fragmentation = 1. - (float(max_empty) / float(np.sum(slot_allocation)))

                lambdas = np.where(slot_allocation == 0)
                if len(lambdas) > 1:
                    lambda_min = np.min(lambdas)
                    lambda_max = np.max(lambdas)
                    # alloc = slot_allocation[lambda_min:lambda_max]
                    blocks = np.split(slot_allocation[lambda_min:lambda_max],
                                      np.where(np.diff(slot_allocation[lambda_min:lambda_max]) != 0)[0] + 1)
                    k = 0
                    for block in blocks:
                        if np.all(block == 1):
                            k += 1
                    # number of blocks of free slots between first and last slot used
                    if k > 0:
                        cur_compactness = ((lambda_max - lambda_min + 1) / len(lambdas)) * (1 / k)
                    else:
                        cur_compactness = 1.
                else:
                    cur_compactness = 1.

            external_fragmentation = ((last_external_fragmentation * last_update) + (cur_external_fragmentation * time_diff)) / self.current_time
            self.topology[node1][node2]['external_fragmentation'] = external_fragmentation
            
            fragmentation = ((last_fragmentation * last_update) + (cur_fragmentation * time_diff)) / self.current_time
            self.topology[node1][node2]['fragmentation'] = fragmentation

            link_compactness = ((last_compactness * last_update) + (cur_compactness * time_diff)) / self.current_time
            self.topology[node1][node2]['compactness'] = link_compactness

        self.topology[node1][node2]['last_update'] = self.current_time

    def _next_service(self):
        if self._new_service:
            return
        at = self.current_time + self.rng.expovariate(1 / self.mean_service_inter_arrival_time)
        self.current_time = at

        ht = self.rng.expovariate(1 / self.mean_service_holding_time)
        src, src_id, dst, dst_id = self._get_node_pair()

        bit_rate = self.rng.randint(self.bit_rate_lower_bound, self.bit_rate_higher_bound)

        # release connections up to this point
        while len(self._events) > 0:
            (time, service_to_release) = heapq.heappop(self._events)
            if time <= self.current_time:
                self._release_path(service_to_release)
            else:  # release is not to be processed yet
                self._add_release(service_to_release)  # puts service back in the queue
                break  # breaks the loop

        self.service = Service(self.services_processed_since_reset, src, src_id,
                               destination=dst, destination_id=dst_id,
                               arrival_time=at, holding_time=ht, bit_rate=bit_rate)
        self._new_service = True

    def _get_path_slot_id(self, action: int) -> (int, int):
        """
        Decodes the single action index into the path index and the slot index to be used.
        :param action: the single action index
        :return: path index and initial slot index encoded in the action
        """
        path = int(action / self.num_spectrum_resources)
        initial_slot = action % self.num_spectrum_resources
        return path, initial_slot

    def get_number_slots(self, path: Path) -> int:
        """
        Method that computes the number of spectrum slots necessary to accommodate the service request into the path.
        The method already adds the guardband.
        """
        return math.ceil(self.service.bit_rate / path.best_modulation['capacity']) + 1

    def is_path_free(self, path: Path, initial_slot: int, number_slots: int, idc) -> bool:
        if initial_slot + number_slots > self.num_spectrum_resources:
            # logging.debug('error index' + env.parameters.rsa_algorithm)
            return False
        for i in range(len(path.node_list) - 1):
            if np.any(self.topology.graph['available_slots'][
                      ((self.topology[path.node_list[i]][path.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * idc)),
                      initial_slot:initial_slot + number_slots] == 0):
                return False
        return True

    def get_available_slots(self, path: Path, idc):
        available_slots = functools.reduce(np.multiply,
            self.topology.graph["available_slots"][[((self.topology[path.node_list[i]][path.node_list[i + 1]]['id']) + (self.topology.number_of_edges() * idc))
                                                    for i in range(len(path.node_list) - 1)], :])
        return available_slots
    
    def get_core(self, action: [int]):
        path, initial_slot = action[0], action[1]
        slots = self.get_number_slots(self.k_shortest_paths[self.service.source, self.service.destination][path])
        for idc in range(self.cores):
            if self.is_path_free(self.k_shortest_paths[self.service.source, self.service.destination][path],
                                      initial_slot, slots, idc):
                break
            else:
                if idc == (self.cores - 1):
                    self.service.accepted = False
        return idc

    def Crosstalk_calculation(self, path: Path, initial_slot: int, number_slots: int, core):
        XT_accomplish = True

        if path.best_modulation['capacity'] == 12.5:
            XT_threshold = -14
        
        if path.best_modulation['capacity'] == 25.0:
            XT_threshold = -18.5

        if path.best_modulation['capacity'] == 37.5:
            XT_threshold = -21

        if path.best_modulation['capacity'] == 50.0:
            XT_threshold = -25

        if core == 0:
          for i in range(len(path.node_list) - 1):
            if np.any(self.topology.graph['available_slots'][
                  ((self.topology[path.node_list[i]][path.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * (core + 1))),
                  initial_slot:initial_slot + number_slots] == 0) or np.any(self.topology.graph['available_slots'][
                  ((self.topology[path.node_list[i]][path.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * (core + 2))),
                  initial_slot:initial_slot + number_slots] == 0):
                XT_required = True
            else:
                XT_required = False

        if core == 1:
          for i in range(len(path.node_list) - 1):
            if np.any(self.topology.graph['available_slots'][
                  ((self.topology[path.node_list[i]][path.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * (core + 1))),
                  initial_slot:initial_slot + number_slots] == 0) or np.any(self.topology.graph['available_slots'][
                  ((self.topology[path.node_list[i]][path.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * (core - 1))),
                  initial_slot:initial_slot + number_slots] == 0):
                XT_required = True
            else:
                XT_required = False

        if core == 2:
          for i in range(len(path.node_list) - 1):
            if np.any(self.topology.graph['available_slots'][
                  ((self.topology[path.node_list[i]][path.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * (core - 1))),
                  initial_slot:initial_slot + number_slots] == 0) or np.any(self.topology.graph['available_slots'][
                  ((self.topology[path.node_list[i]][path.node_list[i + 1]]['index']) + (self.topology.number_of_edges() * (core - 2))),
                  initial_slot:initial_slot + number_slots] == 0):
                XT_required = True
            else:
                XT_required = False
        
        if XT_required == True:
            for i in range(len(path.node_list) - 1):
                L = self.topology[path.node_list[i]][path.node_list[i + 1]]['weight'] 
            r = 0.05
            k = 0.06
            B = 4000000
            Wtr = 0.00003
            LongOnda = 1530 #longitud de onda del primer FSU
            canales = 0.00977 # espaciamiento entre canales
            V1 = 2
            RadioNucleo = 0.0000045
            coefRefra = 1.45
            coefRefraDiff1 = 1.35
            coefRefraDiff2 = 0.65
            wta = 1
            n_vecinos = self.cores - 1

            H = (2*r*pow(k,2)/(B*Wtr))
            LOfsu = LongOnda + ((initial_slot + 1) * canales) - 0.004885   #0,0976
            Lodiff = LOfsu - LongOnda
            coefCore = coefRefra * coefRefraDiff1
            W1 = 1.1428 * V1 - 0.996
            V2 = (2 * 3.14 * RadioNucleo * coefRefra * math.sqrt(2 * coefRefra * coefRefraDiff2)) / LOfsu
            W2 = math.sqrt(pow(V2, 2) + pow(W1, 2))
            HH = H * (W1 / (W1 + ((W2 - W1) * (RadioNucleo / Wtr)))) * math.exp(-4 * (W2 - W1) * (wta))
            AXT = (10 * math.log10(pow(1 - 0.001256 * Lodiff, 4))) + (19.85 * coefCore * math.sqrt(2 * coefRefraDiff1) * ((Lodiff * Wtr) / (LOfsu * LongOnda)))
            Pi = pow(10, AXT / 10)
            XT = (Pi * n_vecinos - (Pi*n_vecinos*math.exp(-(n_vecinos+1)*2*HH*L)))/(1 + (Pi*n_vecinos*math.exp(-(n_vecinos+1)*2*HH*L)))
            XTdb = 10 * math.log10(XT)
            if XTdb < XT_threshold:
                XT_accomplish = True
            else:
                XT_accomplish = False

        return XT_accomplish
    
    def rle(inarray):
        """ run length encoding. Partial credit to R rle function.
            Multi datatype arrays catered for including non Numpy
            returns: tuple (runlengths, startpositions, values) """
        # from: https://stackoverflow.com/questions/1066758/find-length-of-sequences-of-identical-values-in-a-numpy-array-run-length-encodi
        ia = np.asarray(inarray)  # force numpy
        n = len(ia)
        if n == 0:
            return (None, None, None)
        else:
            y = np.array(ia[1:] != ia[:-1])  # pairwise unequal (string safe)
            i = np.append(np.where(y), n - 1)  # must include last element posi
            z = np.diff(np.append(-1, i))  # run lengths
            p = np.cumsum(np.append(0, z))[:-1]  # positions
            return p, ia[i], z

    def get_available_blocks(self, path, idc):
        # get available slots across the whole path
        # 1 if slot is available across all the links
        # zero if not
        available_slots = self.get_available_slots(
            self.k_shortest_paths[self.service.source, self.service.destination][path], idc)

        # getting the number of slots necessary for this service across this path
        slots = self.get_number_slots(self.k_shortest_paths[self.service.source, self.service.destination][path])

        # getting the blocks
        initial_indices, values, lengths = RMSCAEnv.rle(available_slots)

        # selecting the indices where the block is available, i.e., equals to one
        available_indices = np.where(values == 1)

        # selecting the indices where the block has sufficient slots
        sufficient_indices = np.where(lengths >= slots)

        # getting the intersection, i.e., indices where the slots are available in sufficient quantity
        # and using only the J first indices
        final_indices = np.intersect1d(available_indices, sufficient_indices)[:self.j]

        return initial_indices[final_indices], lengths[final_indices]